<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>D3 Paths</title>
    <script type="text/javascript" src="d3/d3.v3.min.js"></script>
    <script type="text/javascript" src="data.js"></script>
    <script type="text/javascript" src="carData.js"></script>
    <script type="text/javascript" src="paths.js"></script>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div id="content">
      <h1>Path Utilization</h1>
      <hr />
      <div id="carTypeCheckboxes"></div>
      <button id="renderButton">Render</button>
      <button id="resetButton">Reset</button>
    </div>
    <div id="status-bar">
      <p id="status-text">
        Ready...
      </p>
      </div>
    <script type="text/javascript">

const uniqueCarTypes = Array.from(new Set(car_data.map(d => d["car-type"])));

      const default_stroke_width = 0.2;

      // Populate the checkboxes with car types vertically
      const checkboxes = d3.select("#carTypeCheckboxes")
        .selectAll(".checkbox-container")
        .data(uniqueCarTypes)
        .enter().append("div")
        .attr("class", "checkbox-container");

      checkboxes.append("label")
        .text(d => ` ${d}  -- `)
        .append("input")
        .attr("type", "checkbox")
        .attr("class", "carTypeCheckbox")
        .attr("value", d => d);

      // Create a tooltip div
      var tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

      // In the interests of readability, we're going to scale the x coordinate to stretch
      // out the graph to fit the wider screen.
      xValues = []
      Object.entries(positions).forEach(e => xValues.push(e[1][0]))
      // positions.values.forEach(v => xValues.append(v[0]));
      max = d3.max(xValues)
      const xScaler = d3.scaleLinear([0, max], [0, 1.7 * max]);

      // set the dimensions and margins of the graph
      var margin = {top: 10, right: 30, bottom: 30, left: 40},
        width = 1800 - margin.left - margin.right,
        height = 1000 - margin.top - margin.bottom;

      // append the svg object to the body of the page
      var svg = d3.select("#content")
      .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

      var counts = new Map();

      const drag = d3.drag()
        .on("start", dragStarted)
        .on("drag", dragging)
        .on("end", dragEnded);

      var link = svg.selectAll(".link")
        .data(data.links)
        .enter().append("line")
        .attr("class", "link")
        .style("stroke", "white")
        .style("stroke-width", default_stroke_width)
        .attr("id", d => {return [d.source, d.target].sort().join("-")})
        .attr("x1", d => xScaler(positions[[d.source, d.target].sort()[0]][0]))  // We have to be deterministic with our ordering on x1,x2,y1,y2
        .attr("y1", d => positions[[d.source, d.target].sort()[0]][1])
        .attr("x2", d => xScaler(positions[[d.source, d.target].sort()[1]][0]))
        .attr("y2", d => positions[[d.source, d.target].sort()[1]][1])
        .attr("class", d => {
          //
          // We need to set from/to classes on the edges so we can easily select them during drag operations
          //
          nodes = [d.source, d.target].sort();
          return `from-${nodes[0]} to-${nodes[1]}`
        })
        .on("mousemove", function (event, d) {
          var idVal = [d.source, d.target].sort().join("-");
          var count = counts.get("#"+idVal) || 0;
          //console.log(idVal)
          //var cords = d3.pointer(this);
          //console.log(cords)
          tooltip.transition()
            .duration(200)
            .style("opacity", 0.9);
          tooltip.html(`Traversals: ${count}`)
            .style("left", event.pageX + 5 + "px")
            .style("top", event.pageY - 50 + "px");
        })
        .on("mouseout", function (event, d) {
          tooltip.transition()
            .duration(500)
            .style("opacity", 0);
        });

      // Initialize the nodes
      var node = svg
        .selectAll(".node")
        .data(data.nodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", (d) => `translate(${xScaler(positions[d.id][0])}, ${positions[d.id][1]})`)
        .call(drag);
        
        node.append("circle")
          .attr("r", 8)
          .style("stroke", "white")
          .style("stroke-width", 2)
          .style("fill", (d) => colorize(d.id));
          
        node.append("text")
          .attr("dx", 12)
          .attr("dy", "0.25em")
          .style("fill", "white")
          .text((d) => d.name );
      
      // Event listener for "Render" button click
      d3.select("#renderButton").on("click", function() {
        renderGraph(); // Render graph on button click
      });

      d3.select("#resetButton").on("click", function() {
        resetGraph(); // Reset graph on button click
      });

      function resetGraph() {
        location.reload()
      }
      
      //
      // Iterate over allPaths and increment the width for invidual edges
      //
      function incrementEdge(index, batch) {
        const strokeScaler = d3.scaleLinear([0, allPaths.length / 10], [default_stroke_width, 10]);
        for (i = 0 ; i < batch ; i++) {
          if (allPaths.length <= index + i) {
            console.log("Interval iteration complete.");
            return;
          }

          var idVal = `#${allPaths[index+i]}`;
          var line = d3.select(idVal)

          c = counts.get(idVal);
          if (c == undefined) {
            c = 0;            
          }
          c += 1;
          counts.set(idVal, c);

          try {
            line.style("stroke-width", strokeScaler(c) + "px");
          } catch (e) {
            // console.log(idVal);
          }
        }
      }

      function getSelectedCarTypes() {
        const selectedCarTypes = [];
        d3.selectAll(".carTypeCheckbox:checked").each(function () {
          selectedCarTypes.push(this.value);
        });
        return selectedCarTypes;
      }

      function renderGraph() {
        const selectedCarTypes = getSelectedCarTypes();
        const filteredCarData = car_data.filter(d => selectedCarTypes.includes(d["car-type"]));

        // Extract car IDs from filtered car data
        const filteredCarIds = filteredCarData.map(d => d["car-id"]);

        // Extract paths for the filtered car IDs
        const filteredPaths = {};
        for (const carId of filteredCarIds) {
          if (vehiclePaths.hasOwnProperty(carId)) {
            filteredPaths[carId] = vehiclePaths[carId];
          }
        }

        // List of edge IDs to increment, in no particular order
        allPaths = [];
        Object.entries(filteredPaths).forEach(e => {
          var i = 0;
          x = filteredPaths[e[0]];

          while (i < x.length - 1) {
              allPaths.push([x[i], x[i+1]].sort().join("-"));
              i++;
          } 
        });

        console.log(`Path Count: ${allPaths.length}`)
        var batch = Math.round(allPaths.length / 1000 + 10);
        console.log(`Batch Size: ${batch}`)
        var index = 0;
        var intervalsRemaining = allPaths.length;
        var intervalId = setInterval(function() {
          d3.select("#status-text").html(`${intervalsRemaining} intervals remaining`);
          incrementEdge(index, batch);
          intervalsRemaining -= batch;
          index += batch;

          if (intervalsRemaining <= 0) {        
            clearInterval(intervalId);
            d3.select("#status-text").html("Interval iteration complete");
          }
        }, 1);
      }

      // Define drag event handlers
      function dragStarted(event, d) {
        d3.select(this).raise();
      }

      function dragging(event, d) {
        // Move the node group itself
        d3.select(this).attr("transform", `translate(${d.x = event.x}, ${d.y = event.y})`);
        
        // Move source of all relevant edges
        d3.selectAll(`.from-${d.id}`).attr("x1", event.x).attr("y1", event.y);

        // Move the target of all relevant edges
        d3.selectAll(`.to-${d.id}`).attr("x2", event.x).attr("y2", event.y);
      }

      function dragEnded(event, d) {    
        const duration = 1000;   
        const ease = d3.easeQuad; 
        const position = positions[d.id]

        d3.select(this)
          .transition()
          .duration(duration)
          .ease(ease)
          .attr("transform", `translate(${d.x = xScaler(position[0])}, ${d.y = position[1]})`);        

        // // Move source of all relevant edges
        d3.selectAll(`.from-${d.id}`)
          .transition()
          .duration(duration)
          .ease(ease)
          .attr("x1", xScaler(position[0])).attr("y1", position[1]);

        // // Move the target of all relevant edges
        d3.selectAll(`.to-${d.id}`)
          .transition()
          .duration(duration)
          .ease(ease)
          .attr("x2", xScaler(position[0])).attr("y2", position[1]);
      }

    </script>
  </body>
</html>    